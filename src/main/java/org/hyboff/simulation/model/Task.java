package org.hyboff.simulation.model;

import org.hyboff.simulation.util.SimulationClock;

/**
 * Represents a computational task in the simulation.
 * Tasks are generated by IoT devices and processed by Fog devices.
 */
public class Task {
    private String id;
    private int millionInstructions; // Size of task in Million Instructions (MI)
    private int remainingMI;        // Remaining Million Instructions to process
    private int deadline;           // Deadline in seconds
    private boolean isUrgent;       // Flag for urgent tasks that may require dynamic offloading
    private double creationTime;     // Simulation time when the task was created
    private double startTime;        // Simulation time when the task processing started
    private double completionTime;   // Simulation time when the task was completed
    private double responseTime;     // Total response time (completion - creation)
    private String sourceFogId;      // ID of the fog device that generated/received this task
    private String targetFogId;      // ID of the fog device this task was offloaded to
    private String sourceId;         // ID of the source device (for network tracking)
    
    public Task(String id, int millionInstructions, int deadline, boolean isUrgent) {
        this.id = id;
        this.millionInstructions = millionInstructions;
        this.remainingMI = millionInstructions;
        this.deadline = deadline;
        this.isUrgent = isUrgent;
        this.creationTime = SimulationClock.clock();
        this.startTime = -1;
        this.completionTime = -1;
        this.responseTime = 0;
    }
    
    // Getters
    public String getId() {
        return id;
    }
    
    public int getMillionInstructions() {
        return millionInstructions;
    }
    
    /**
     * Get task size - alias for getMillionInstructions() for FogDevice compatibility
     */
    public int getSize() {
        return millionInstructions;
    }
    
    public int getDeadline() {
        return deadline;
    }
    
    public boolean isUrgent() {
        return isUrgent;
    }
    
    public double getCreationTime() {
        return creationTime;
    }
    
    public double getResponseTime() {
        return responseTime;
    }
    
    public void setSourceFogId(String fogId) {
        this.sourceFogId = fogId;
    }
    
    public String getSourceFogId() {
        return sourceFogId;
    }
    
    public void setTargetFogId(String fogId) {
        this.targetFogId = fogId;
    }
    
    public String getTargetFogId() {
        return targetFogId;
    }
    
    public void setSourceId(String sourceId) {
        this.sourceId = sourceId;
    }
    
    public String getSourceId() {
        return sourceId;
    }
    
    /**
     * Mark the task as started
     */
    public void start() {
        if (startTime < 0) {
            this.startTime = SimulationClock.clock();
        }
    }
    
    /**
     * Update the progress of this task based on the MIPS available
     * @param availableMips MIPS available to process this task
     */
    public void updateProgress(int availableMips) {
        if (startTime < 0) {
            // Task not started yet
            start();
        }
        
        // Calculate how many MI can be processed in this tick
        // Ensure a minimum processing rate to guarantee task completion
        int minimumProcessingRate = Math.max(100, millionInstructions / 10);
        int effectiveMips = Math.max(minimumProcessingRate, availableMips);
        
        // Process the task with the effective MIPS
        int processedMI = Math.min(effectiveMips, remainingMI);
        remainingMI -= processedMI;
        
        // For simulation purposes, accelerate task completion if it's taking too long
        double currentTime = SimulationClock.clock();
        if (startTime > 0 && (currentTime - startTime) > deadline * 2) {
            // If task has been running for more than twice its deadline, complete it
            remainingMI = 0;
        }
        
        // Check if task is completed
        if (remainingMI <= 0) {
            complete();
            // Disabled verbose task completion messages
            // System.out.println("Task " + id + " completed successfully");
        }
    }
    
    /**
     * Add additional response time (e.g., for communication delays)
     * @param additionalTime time to add in milliseconds
     */
    public void addResponseTime(double additionalTime) {
        this.responseTime += additionalTime;
    }
    
    /**
     * Decrement the deadline counter by 1 second
     */
    public void decrementDeadline() {
        this.deadline--;    
    }
    
    /**
     * Mark task as completed
     */
    public void complete() {
        // Guard against double completion
        if (!isCompleted()) {
            this.completionTime = SimulationClock.clock();
            this.responseTime = this.completionTime - this.creationTime;
            this.remainingMI = 0; // Ensure remainingMI is set to 0
        }
    }
    
    /**
     * Check if the task has been completed
     */
    public boolean isCompleted() {
        return completionTime > 0;
    }
    
    @Override
    public String toString() {
        return "Task " + id;
    }
}
